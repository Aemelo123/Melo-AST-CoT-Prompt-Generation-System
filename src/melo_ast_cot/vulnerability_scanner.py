'''
Vulnerability scanner using Bandit and Semgrep for external validation.

References:
    - PyCQA. (2024). Bandit (Version 1.7.10) [Computer software]. GitHub.
      https://github.com/PyCQA/bandit

    - Semgrep. (2024). Semgrep [Computer software]. GitHub.
      https://github.com/semgrep/semgrep
'''
import json
import subprocess
import tempfile
from pathlib import Path


def _run_scanner(code: str, command: list) -> dict:
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(code)
        temp_path = Path(f.name)

    try:
        result = subprocess.run(command + [str(temp_path)], capture_output=True, text=True)
        return json.loads(result.stdout) if result.stdout else {}
    finally:
        temp_path.unlink()


def run_bandit(code: str) -> dict:
    return _run_scanner(code, ['bandit', '-f', 'json', '-ll'])


def run_semgrep(code: str) -> dict:
    return _run_scanner(code, ['semgrep', '--config', 'p/python', '--json'])


def extract_bandit_findings(bandit_output: dict) -> list:
    findings = []
    for result in bandit_output.get("results", []):
        findings.append({
            "tool": "bandit",
            "rule_id": result.get("test_id"),
            "cwe_id": result.get("issue_cwe", {}).get("id"),
            "severity": result.get("issue_severity"),
            "message": result.get("issue_text"),
        })
    return findings


def extract_semgrep_findings(semgrep_output: dict) -> list:
    findings = []
    for result in semgrep_output.get("results", []):
        metadata = result.get("extra", {}).get("metadata", {})
        cwe = metadata.get("cwe", [])
        cwe_id = cwe[0] if cwe else None

        findings.append({
            "tool": "semgrep",
            "rule_id": result.get("check_id"),
            "cwe_id": cwe_id,
            "severity": result.get("extra", {}).get("severity"),
            "message": result.get("extra", {}).get("message"),
        })
    return findings


def calculate_vulnerability_density(num_vulnerabilities: int, loc: int) -> float:
    if loc == 0:
        return 0.0
    return (num_vulnerabilities / loc) * 1000


def scan_code(code: str) -> dict:
    bandit_output = run_bandit(code)
    semgrep_output = run_semgrep(code)

    bandit_findings = extract_bandit_findings(bandit_output)
    semgrep_findings = extract_semgrep_findings(semgrep_output)
    all_findings = bandit_findings + semgrep_findings

    loc = bandit_output.get("metrics", {}).get("_totals", {}).get("loc", 0)
    density = calculate_vulnerability_density(len(all_findings), loc)

    return {
        "findings": all_findings,
        "num_vulnerabilities": len(all_findings),
        "loc": loc,
        "vulnerability_density": density,
    }